{"changed":true,"filter":false,"title":"proc.c","tooltip":"/xv6/proc.c","value":"#include \"types.h\"\n#include \"defs.h\"\n#include \"param.h\"\n#include \"memlayout.h\"\n#include \"mmu.h\"\n#include \"x86.h\"\n#include \"proc.h\"\n#include \"spinlock.h\"\n\nstruct {\n  struct spinlock lock;\n  struct proc proc[NPROC];\n} ptable;\n\nstatic struct proc *initproc;\n\nint nextpid = 1;\n//int maxpriority = 63;         // MOD 4/30 : PRISCHED\nextern void forkret(void);\nextern void trapret(void);\n\nstatic void wakeup1(void *chan);\n\nvoid\npinit(void)\n{\n  initlock(&ptable.lock, \"ptable\");\n}\n\n//PAGEBREAK: 32\n// Look in the process table for an UNUSED proc.\n// If found, change state to EMBRYO and initialize\n// state required to run in the kernel.\n// Otherwise return 0.\nstatic struct proc*\nallocproc(void)\n{\n  struct proc *p;\n  char *sp;\n\n  acquire(&ptable.lock);\n\n  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)\n    if(p->state == UNUSED)\n      goto found;\n\n  release(&ptable.lock);\n  return 0;\n\nfound:\n  p->state = EMBRYO;\n  p->pid = nextpid++;\n//  p->priority = 20;      // MOD 4/30 : PRISCHED - Set default priority to 20.\n\n  release(&ptable.lock);\n\n  // Allocate kernel stack.\n  if((p->kstack = kalloc()) == 0){\n    p->state = UNUSED;\n    return 0;\n  }\n  sp = p->kstack + KSTACKSIZE;\n\n  // Leave room for trap frame.\n  sp -= sizeof *p->tf;\n  p->tf = (struct trapframe*)sp;\n\n  // Set up new context to start executing at forkret,\n  // which returns to trapret.\n  sp -= 4;\n  *(uint*)sp = (uint)trapret;\n\n  sp -= sizeof *p->context;\n  p->context = (struct context*)sp;\n  memset(p->context, 0, sizeof *p->context);\n  p->context->eip = (uint)forkret;\n\n  return p;\n}\n\n//PAGEBREAK: 32\n// Set up first user process.\nvoid\nuserinit(void)\n{\n  struct proc *p;\n  extern char _binary_initcode_start[], _binary_initcode_size[];\n\n  p = allocproc();\n  \n  initproc = p;\n  if((p->pgdir = setupkvm()) == 0)\n    panic(\"userinit: out of memory?\");\n  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);\n  p->sz = PGSIZE;\n  memset(p->tf, 0, sizeof(*p->tf));\n  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;\n  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;\n  p->tf->es = p->tf->ds;\n  p->tf->ss = p->tf->ds;\n  p->tf->eflags = FL_IF;\n  p->tf->esp = PGSIZE;\n  p->tf->eip = 0;  // beginning of initcode.S\n\n  safestrcpy(p->name, \"initcode\", sizeof(p->name));\n  p->cwd = namei(\"/\");\n\n  // this assignment to p->state lets other cores\n  // run this process. the acquire forces the above\n  // writes to be visible, and the lock is also needed\n  // because the assignment might not be atomic.\n  acquire(&ptable.lock);\n\n  p->state = RUNNABLE;\n\n  release(&ptable.lock);\n}\n\n// Grow current process's memory by n bytes.\n// Return 0 on success, -1 on failure.\nint\ngrowproc(int n)\n{\n  uint sz;\n\n  sz = proc->sz;\n  if(n > 0){\n    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)\n      return -1;\n  } else if(n < 0){\n    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)\n      return -1;\n  }\n  proc->sz = sz;\n  switchuvm(proc);\n  return 0;\n}\n\n// Create a new process copying p as the parent.\n// Sets up stack to return as if from system call.\n// Caller must set state of returned proc to RUNNABLE.\nint\nfork(void)\n{\n  int i, pid;\n  struct proc *np;\n\n  // Allocate process.\n  if((np = allocproc()) == 0){\n    return -1;\n  }\n\n  // Copy process state from p.\n  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){\n    kfree(np->kstack);\n    np->kstack = 0;\n    np->state = UNUSED;\n    return -1;\n  }\n  np->sz = proc->sz;\n  np->parent = proc;\n  *np->tf = *proc->tf;\n\n  // Clear %eax so that fork returns 0 in the child.\n  np->tf->eax = 0;\n\n  for(i = 0; i < NOFILE; i++)\n    if(proc->ofile[i])\n      np->ofile[i] = filedup(proc->ofile[i]);\n  np->cwd = idup(proc->cwd);\n\n  safestrcpy(np->name, proc->name, sizeof(proc->name));\n\n  pid = np->pid;\n\n  acquire(&ptable.lock);\n\n  np->state = RUNNABLE;\n\n  release(&ptable.lock);\n\n  return pid;\n}\n\n// Exit the current process.  Does not return.\n// An exited process remains in the zombie state\n// until its parent calls wait() to find out it exited.\n\n// MOD - 4/18 : Returns a status.\n\nvoid\nexit(int status)\n{\n  struct proc *p;\n  int fd;\n  \n  // cprintf(\"exit status %d\", proc->status);\n\n  if(proc == initproc)\n    panic(\"init exiting\");\n\n  // Close all open files.\n  for(fd = 0; fd < NOFILE; fd++){\n    if(proc->ofile[fd]){\n      fileclose(proc->ofile[fd]);\n      proc->ofile[fd] = 0;\n    }\n  }\n\n  begin_op();\n  iput(proc->cwd);\n  end_op();\n  proc->cwd = 0;\n\n  acquire(&ptable.lock);\n\n  // Parent might be sleeping in wait().\n  wakeup1(proc->parent);\n\n  // Pass abandoned children to init.\n  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){\n    if(p->parent == proc){\n      p->parent = initproc;\n      if(p->state == ZOMBIE)\n        wakeup1(initproc);\n    }\n  }\n  \n  proc->status = status; // MOD - 4/18\n  // Jump into the scheduler, never to return.\n  proc->state = ZOMBIE;\n  sched();\n  panic(\"zombie exit\");\n}\n\n// Wait for a child process to exit and return its pid.\n// Return -1 if this process has no children.\nint\nwait(int * status)\n{\n  struct proc *p;\n  int havekids, pid;\n\n  acquire(&ptable.lock);\n  for(;;){\n    // Scan through table looking for exited children.\n    havekids = 0;\n    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){\n      if(p->parent != proc)\n        continue;\n      havekids = 1;\n      if(p->state == ZOMBIE){\n        // Found one.\n        \n        // MOD - 4/29\n        if (p->status != 0) {\n          *status = p->status;\n        } else *status = 0;\n        \n        pid = p->pid;\n        kfree(p->kstack);\n        p->kstack = 0;\n        freevm(p->pgdir);\n        p->pid = 0;\n        p->parent = 0;\n        p->name[0] = 0;\n        p->killed = 0;\n        p->state = UNUSED;\n        release(&ptable.lock);\n        return pid;\n      }\n    }\n\n    // No point waiting if we don't have any children.\n    if(!havekids || proc->killed){\n      release(&ptable.lock);\n      return -1;\n    }\n\n    // Wait for children to exit.  (See wakeup1 call in proc_exit.)\n    sleep(proc, &ptable.lock);  //DOC: wait-sleep\n  }\n}\n\n// This system call must act like wait system call with the\n// following additional properties:\n// The system call must wait for a process (not necessary a child process)\n// with a pid that equals to one provided by the pid argument. The return\n// value must be the process id of the process that was terminated or -1\n// if this process does not exist or if an unexpected error occurred. We\n// are required only to implement a nonblocking waitpid where the kernel\n// prevents the current process from execution until a process with the\n// given pid terminates.\n\nint\nwaitpid(int pid, int * status, int options)\n{\n  struct proc *p;\n  int havekids;   // MOD - 4/29 : now using parameter pid\n\n  acquire(&ptable.lock);\n  for(;;){\n    // Scan through table looking for exited children.\n    havekids = 0;\n    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){\n      if(p->pid != pid) {  // MOD - 4/29\n        continue;\n      }\n      \n      havekids = 1;\n      if(p->state == ZOMBIE){\n        // Found one.\n        \n        // MOD - 4/29\n        if (p->status != 0) {\n          *status = p->status;\n        } else *status = 0;\n        \n        pid = p->pid;\n        kfree(p->kstack);\n        p->kstack = 0;\n        freevm(p->pgdir);\n        p->pid = 0;\n        p->parent = 0;\n        p->name[0] = 0;\n        p->killed = 0;\n        p->state = UNUSED;\n        release(&ptable.lock);\n        return pid;\n      } else {\n        p->procswaiting++;\n        p->wpidlist[p->procswaiting] = proc;\n      }\n    }\n\n    // No point waiting if we don't have any children.\n    if(!havekids || proc->killed){\n      release(&ptable.lock);\n      return -1;\n    }\n\n    // Wait for children to exit.  (See wakeup1 call in proc_exit.)\n    sleep(proc, &ptable.lock);  //DOC: wait-sleep\n  }\n}\n\nint\ngetprocpriority(void)\n{\n  struct proc *p;\n  // initialize to lowest priority (will go up as higher priority processes found)\n  int priority = 65000;\n  \n  // go through ptable\n  acquire(&ptable.lock);\n  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {\n    // look for runnable processes\n    if(p->state != RUNNABLE) {\n          continue;\n    }\n    \n    if(priority == 0) {\n      priority = p->priority;\n    } else {\n      // look for higher priority process and assign 'priority' with new highest\n      // priority\n      if (p->priority < priority) {\n        priority = p->priority;\n      }\n    }\n  }\n  \n  release(&ptable.lock);\n  return priority;\n}\n\n//PAGEBREAK: 42\n// Per-CPU process scheduler.\n// Each CPU calls scheduler() after setting itself up.\n// Scheduler never returns.  It loops, doing:\n//  - choose a process to run\n//  - swtch to start running that process\n//  - eventually that process transfers control\n//      via swtch back to the scheduler.\n\nvoid\nscheduler(void)\n{\n  struct proc *p;\n  int priority = 0;   // hold priority value\n\n  for(;;) {\n    // Enable interrupts on this processor.\n    sti();\n\n    /* *** BEGIN MOD: 4/30 PRISCHED\n    \n    for(priority = 0; priority < maxpriority; priority++) {\n      acquire(&ptable.lock);\n      // Loop over process table looking for process to run.\n      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){\n        if(p->state != RUNNABLE)\n          continue;\n        // PRISCHED: Now check and see if that process matches our current\n        // priority level.\n        if (p->priority == priority) {\n          // If it does, get it running.\n          proc = p;\n          switchuvm(p);\n          p->state = RUNNING;\n          swtch(&cpu->scheduler, proc->context);\n          switchkvm();\n        }\n        // Process is done running for now.\n        // It should have changed its p->state before coming back.\n        proc = 0;\n      }\n      release(&ptable.lock);\n    }*/\n    \n    // Old Round Robin Scheduler\n\n    // Loop over process table looking for process to run.\n    acquire(&ptable.lock);\n    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++) {\n      if(p->state != RUNNABLE) {\n        continue;\n      }\n      \n      release(&ptable.lock);\n      \n      priority = getprocpriority();\n      \n      acquire(&ptable.lock);\n      \n      if (priority < p->priority) {\n        p->priority = priority;\n      }\n      // Switch to chosen process.  It is the process's job\n      // to release ptable.lock and then reacquire it\n      // before jumping back to us.\n      proc = p;\n      switchuvm(p);\n      p->state = RUNNING;\n      swtch(&cpu->scheduler, p->context);\n      switchkvm();\n\n      // Process is done running for now.\n      // It should have changed its p->state before coming back.\n      proc = 0;\n    }\n    release(&ptable.lock);\n  }\n}\n\nint\nsetpriority(int num)\n{\n  if (num < 0) {\n    num = 0;\n  } else if (num > 63) {\n    num = 63;\n  }\n  \n  proc->priority = num;\n  \n  return 0;\n}\n\n// Enter scheduler.  Must hold only ptable.lock\n// and have changed proc->state. Saves and restores\n// intena because intena is a property of this\n// kernel thread, not this CPU. It should\n// be proc->intena and proc->ncli, but that would\n// break in the few places where a lock is held but\n// there's no process.\nvoid\nsched(void)\n{\n  int intena;\n\n  if(!holding(&ptable.lock))\n    panic(\"sched ptable.lock\");\n  if(cpu->ncli != 1)\n    panic(\"sched locks\");\n  if(proc->state == RUNNING)\n    panic(\"sched running\");\n  if(readeflags()&FL_IF)\n    panic(\"sched interruptible\");\n  intena = cpu->intena;\n  swtch(&proc->context, cpu->scheduler);\n  cpu->intena = intena;\n}\n\n// Give up the CPU for one scheduling round.\nvoid\nyield(void)\n{\n  acquire(&ptable.lock);  //DOC: yieldlock\n  proc->state = RUNNABLE;\n  sched();\n  release(&ptable.lock);\n}\n\n// A fork child's very first scheduling by scheduler()\n// will swtch here.  \"Return\" to user space.\nvoid\nforkret(void)\n{\n  static int first = 1;\n  // Still holding ptable.lock from scheduler.\n  release(&ptable.lock);\n\n  if (first) {\n    // Some initialization functions must be run in the context\n    // of a regular process (e.g., they call sleep), and thus cannot\n    // be run from main().\n    first = 0;\n    iinit(ROOTDEV);\n    initlog(ROOTDEV);\n  }\n\n  // Return to \"caller\", actually trapret (see allocproc).\n}\n\n// Atomically release lock and sleep on chan.\n// Reacquires lock when awakened.\nvoid\nsleep(void *chan, struct spinlock *lk)\n{\n  if(proc == 0)\n    panic(\"sleep\");\n\n  if(lk == 0)\n    panic(\"sleep without lk\");\n\n  // Must acquire ptable.lock in order to\n  // change p->state and then call sched.\n  // Once we hold ptable.lock, we can be\n  // guaranteed that we won't miss any wakeup\n  // (wakeup runs with ptable.lock locked),\n  // so it's okay to release lk.\n  if(lk != &ptable.lock){  //DOC: sleeplock0\n    acquire(&ptable.lock);  //DOC: sleeplock1\n    release(lk);\n  }\n\n  // Go to sleep.\n  proc->chan = chan;\n  proc->state = SLEEPING;\n  sched();\n\n  // Tidy up.\n  proc->chan = 0;\n\n  // Reacquire original lock.\n  if(lk != &ptable.lock){  //DOC: sleeplock2\n    release(&ptable.lock);\n    acquire(lk);\n  }\n}\n\n//PAGEBREAK!\n// Wake up all processes sleeping on chan.\n// The ptable lock must be held.\nstatic void\nwakeup1(void *chan)\n{\n  struct proc *p;\n\n  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)\n    if(p->state == SLEEPING && p->chan == chan)\n      p->state = RUNNABLE;\n}\n\n// Wake up all processes sleeping on chan.\nvoid\nwakeup(void *chan)\n{\n  acquire(&ptable.lock);\n  wakeup1(chan);\n  release(&ptable.lock);\n}\n\n// Kill the process with the given pid.\n// Process won't exit until it returns\n// to user space (see trap in trap.c).\nint\nkill(int pid)\n{\n  struct proc *p;\n\n  acquire(&ptable.lock);\n  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){\n    if(p->pid == pid){\n      p->killed = 1;\n      // Wake process from sleep if necessary.\n      if(p->state == SLEEPING)\n        p->state = RUNNABLE;\n      release(&ptable.lock);\n      return 0;\n    }\n  }\n  release(&ptable.lock);\n  return -1;\n}\n\n//PAGEBREAK: 36\n// Print a process listing to console.  For debugging.\n// Runs when user types ^P on console.\n// No lock to avoid wedging a stuck machine further.\nvoid\nprocdump(void)\n{\n  static char *states[] = {\n  [UNUSED]    \"unused\",\n   [EMBRYO]    \"embryo\",\n  [SLEEPING]  \"sleep \",\n  [RUNNABLE]  \"runble\",\n  [RUNNING]   \"run   \",\n  [ZOMBIE]    \"zombie\"\n  };\n  int i;\n  struct proc *p;\n  char *state;\n  uint pc[10];\n\n  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){\n    if(p->state == UNUSED)\n      continue;\n    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])\n      state = states[p->state];\n    else\n      state = \"???\";\n    cprintf(\"%d %s %s\", p->pid, state, p->name);\n    if(p->state == SLEEPING){\n      getcallerpcs((uint*)p->context->ebp+2, pc);\n      for(i=0; i<10 && pc[i] != 0; i++)\n        cprintf(\" %p\", pc[i]);\n    }\n    cprintf(\"\\n\");\n  }\n}\n\nvoid \nhello(void) {\n  cprintf(\"hello!\\n\");\n}\n","undoManager":{"mark":95,"position":100,"stack":[[{"start":{"row":459,"column":5},"end":{"row":459,"column":7},"action":"insert","lines":["()"],"id":2042}],[{"start":{"row":459,"column":6},"end":{"row":459,"column":7},"action":"insert","lines":["p"],"id":2043}],[{"start":{"row":459,"column":7},"end":{"row":459,"column":8},"action":"insert","lines":["r"],"id":2044}],[{"start":{"row":459,"column":8},"end":{"row":459,"column":9},"action":"insert","lines":["i"],"id":2045}],[{"start":{"row":459,"column":9},"end":{"row":459,"column":10},"action":"insert","lines":["o"],"id":2046}],[{"start":{"row":459,"column":9},"end":{"row":459,"column":10},"action":"remove","lines":["o"],"id":2047}],[{"start":{"row":459,"column":8},"end":{"row":459,"column":9},"action":"remove","lines":["i"],"id":2048}],[{"start":{"row":459,"column":7},"end":{"row":459,"column":8},"action":"remove","lines":["r"],"id":2049}],[{"start":{"row":459,"column":6},"end":{"row":459,"column":7},"action":"remove","lines":["p"],"id":2050}],[{"start":{"row":459,"column":6},"end":{"row":459,"column":7},"action":"insert","lines":["n"],"id":2051}],[{"start":{"row":459,"column":7},"end":{"row":459,"column":8},"action":"insert","lines":["u"],"id":2052}],[{"start":{"row":459,"column":8},"end":{"row":459,"column":9},"action":"insert","lines":["m"],"id":2053}],[{"start":{"row":459,"column":9},"end":{"row":459,"column":10},"action":"insert","lines":[" "],"id":2054}],[{"start":{"row":459,"column":10},"end":{"row":459,"column":11},"action":"insert","lines":["<"],"id":2055}],[{"start":{"row":459,"column":11},"end":{"row":459,"column":12},"action":"insert","lines":[" "],"id":2056}],[{"start":{"row":459,"column":12},"end":{"row":459,"column":13},"action":"insert","lines":["0"],"id":2057}],[{"start":{"row":459,"column":14},"end":{"row":459,"column":15},"action":"insert","lines":[" "],"id":2058}],[{"start":{"row":459,"column":15},"end":{"row":459,"column":16},"action":"insert","lines":["{"],"id":2059}],[{"start":{"row":459,"column":16},"end":{"row":461,"column":3},"action":"insert","lines":["","    ","  }"],"id":2060}],[{"start":{"row":460,"column":4},"end":{"row":460,"column":5},"action":"insert","lines":["p"],"id":2061}],[{"start":{"row":460,"column":5},"end":{"row":460,"column":6},"action":"insert","lines":["r"],"id":2062}],[{"start":{"row":460,"column":6},"end":{"row":460,"column":7},"action":"insert","lines":["i"],"id":2063}],[{"start":{"row":460,"column":7},"end":{"row":460,"column":8},"action":"insert","lines":["o"],"id":2064}],[{"start":{"row":460,"column":8},"end":{"row":460,"column":9},"action":"insert","lines":["r"],"id":2065}],[{"start":{"row":460,"column":9},"end":{"row":460,"column":10},"action":"insert","lines":["i"],"id":2066}],[{"start":{"row":460,"column":10},"end":{"row":460,"column":11},"action":"insert","lines":["t"],"id":2067}],[{"start":{"row":460,"column":11},"end":{"row":460,"column":12},"action":"insert","lines":["y"],"id":2068}],[{"start":{"row":460,"column":11},"end":{"row":460,"column":12},"action":"remove","lines":["y"],"id":2069}],[{"start":{"row":460,"column":10},"end":{"row":460,"column":11},"action":"remove","lines":["t"],"id":2070}],[{"start":{"row":460,"column":9},"end":{"row":460,"column":10},"action":"remove","lines":["i"],"id":2071}],[{"start":{"row":460,"column":8},"end":{"row":460,"column":9},"action":"remove","lines":["r"],"id":2072}],[{"start":{"row":460,"column":7},"end":{"row":460,"column":8},"action":"remove","lines":["o"],"id":2073}],[{"start":{"row":460,"column":6},"end":{"row":460,"column":7},"action":"remove","lines":["i"],"id":2074}],[{"start":{"row":460,"column":5},"end":{"row":460,"column":6},"action":"remove","lines":["r"],"id":2075}],[{"start":{"row":460,"column":4},"end":{"row":460,"column":5},"action":"remove","lines":["p"],"id":2076}],[{"start":{"row":460,"column":4},"end":{"row":460,"column":5},"action":"insert","lines":["n"],"id":2077}],[{"start":{"row":460,"column":5},"end":{"row":460,"column":6},"action":"insert","lines":["u"],"id":2078}],[{"start":{"row":460,"column":6},"end":{"row":460,"column":7},"action":"insert","lines":["m"],"id":2079}],[{"start":{"row":460,"column":7},"end":{"row":460,"column":8},"action":"insert","lines":[" "],"id":2080}],[{"start":{"row":460,"column":8},"end":{"row":460,"column":9},"action":"insert","lines":["="],"id":2081}],[{"start":{"row":460,"column":9},"end":{"row":460,"column":10},"action":"insert","lines":[" "],"id":2082}],[{"start":{"row":460,"column":10},"end":{"row":460,"column":11},"action":"insert","lines":["0"],"id":2083}],[{"start":{"row":460,"column":11},"end":{"row":460,"column":12},"action":"insert","lines":[";"],"id":2084}],[{"start":{"row":461,"column":3},"end":{"row":461,"column":4},"action":"insert","lines":[" "],"id":2085}],[{"start":{"row":461,"column":4},"end":{"row":461,"column":5},"action":"insert","lines":["e"],"id":2086}],[{"start":{"row":461,"column":5},"end":{"row":461,"column":6},"action":"insert","lines":["l"],"id":2087}],[{"start":{"row":461,"column":6},"end":{"row":461,"column":7},"action":"insert","lines":["s"],"id":2088}],[{"start":{"row":461,"column":7},"end":{"row":461,"column":8},"action":"insert","lines":["e"],"id":2089}],[{"start":{"row":461,"column":8},"end":{"row":461,"column":9},"action":"insert","lines":[" "],"id":2090}],[{"start":{"row":461,"column":9},"end":{"row":461,"column":10},"action":"insert","lines":["i"],"id":2091}],[{"start":{"row":461,"column":10},"end":{"row":461,"column":11},"action":"insert","lines":["f"],"id":2092}],[{"start":{"row":461,"column":11},"end":{"row":461,"column":12},"action":"insert","lines":[" "],"id":2093}],[{"start":{"row":461,"column":12},"end":{"row":461,"column":14},"action":"insert","lines":["()"],"id":2094}],[{"start":{"row":461,"column":13},"end":{"row":461,"column":14},"action":"insert","lines":["n"],"id":2095}],[{"start":{"row":461,"column":14},"end":{"row":461,"column":15},"action":"insert","lines":["u"],"id":2096}],[{"start":{"row":461,"column":15},"end":{"row":461,"column":16},"action":"insert","lines":["m"],"id":2097}],[{"start":{"row":461,"column":16},"end":{"row":461,"column":17},"action":"insert","lines":[" "],"id":2098}],[{"start":{"row":461,"column":17},"end":{"row":461,"column":18},"action":"insert","lines":[">"],"id":2099}],[{"start":{"row":461,"column":18},"end":{"row":461,"column":19},"action":"insert","lines":[" "],"id":2100}],[{"start":{"row":461,"column":19},"end":{"row":461,"column":20},"action":"insert","lines":["6"],"id":2101}],[{"start":{"row":461,"column":20},"end":{"row":461,"column":21},"action":"insert","lines":["3"],"id":2102}],[{"start":{"row":461,"column":22},"end":{"row":461,"column":23},"action":"insert","lines":[" "],"id":2103}],[{"start":{"row":461,"column":23},"end":{"row":461,"column":24},"action":"insert","lines":["{"],"id":2104}],[{"start":{"row":461,"column":24},"end":{"row":463,"column":3},"action":"insert","lines":["","    ","  }"],"id":2105}],[{"start":{"row":462,"column":4},"end":{"row":462,"column":5},"action":"insert","lines":["n"],"id":2106}],[{"start":{"row":462,"column":5},"end":{"row":462,"column":6},"action":"insert","lines":["u"],"id":2107}],[{"start":{"row":462,"column":6},"end":{"row":462,"column":7},"action":"insert","lines":["m"],"id":2108}],[{"start":{"row":462,"column":7},"end":{"row":462,"column":8},"action":"insert","lines":[" "],"id":2109}],[{"start":{"row":462,"column":8},"end":{"row":462,"column":9},"action":"insert","lines":["="],"id":2110}],[{"start":{"row":462,"column":9},"end":{"row":462,"column":10},"action":"insert","lines":[" "],"id":2111}],[{"start":{"row":462,"column":10},"end":{"row":462,"column":11},"action":"insert","lines":["6"],"id":2112}],[{"start":{"row":462,"column":11},"end":{"row":462,"column":12},"action":"insert","lines":["3"],"id":2113}],[{"start":{"row":462,"column":12},"end":{"row":462,"column":13},"action":"insert","lines":[";"],"id":2114}],[{"start":{"row":463,"column":3},"end":{"row":464,"column":0},"action":"insert","lines":["",""],"id":2115},{"start":{"row":464,"column":0},"end":{"row":464,"column":2},"action":"insert","lines":["  "]}],[{"start":{"row":465,"column":2},"end":{"row":466,"column":0},"action":"insert","lines":["",""],"id":2116},{"start":{"row":466,"column":0},"end":{"row":466,"column":2},"action":"insert","lines":["  "]}],[{"start":{"row":465,"column":2},"end":{"row":465,"column":3},"action":"insert","lines":["p"],"id":2117}],[{"start":{"row":465,"column":3},"end":{"row":465,"column":4},"action":"insert","lines":["r"],"id":2118}],[{"start":{"row":465,"column":4},"end":{"row":465,"column":5},"action":"insert","lines":["o"],"id":2119}],[{"start":{"row":465,"column":5},"end":{"row":465,"column":6},"action":"insert","lines":["c"],"id":2120}],[{"start":{"row":465,"column":6},"end":{"row":465,"column":7},"action":"insert","lines":["-"],"id":2121}],[{"start":{"row":465,"column":7},"end":{"row":465,"column":8},"action":"insert","lines":[">"],"id":2122}],[{"start":{"row":465,"column":8},"end":{"row":465,"column":9},"action":"insert","lines":["p"],"id":2123}],[{"start":{"row":465,"column":9},"end":{"row":465,"column":10},"action":"insert","lines":["r"],"id":2124}],[{"start":{"row":465,"column":10},"end":{"row":465,"column":11},"action":"insert","lines":["i"],"id":2125}],[{"start":{"row":465,"column":11},"end":{"row":465,"column":12},"action":"insert","lines":["o"],"id":2126}],[{"start":{"row":465,"column":12},"end":{"row":465,"column":13},"action":"insert","lines":["r"],"id":2127}],[{"start":{"row":465,"column":13},"end":{"row":465,"column":14},"action":"insert","lines":["i"],"id":2128}],[{"start":{"row":465,"column":14},"end":{"row":465,"column":15},"action":"insert","lines":["t"],"id":2129}],[{"start":{"row":465,"column":15},"end":{"row":465,"column":16},"action":"insert","lines":["y"],"id":2130}],[{"start":{"row":465,"column":16},"end":{"row":465,"column":17},"action":"insert","lines":[" "],"id":2131}],[{"start":{"row":465,"column":17},"end":{"row":465,"column":18},"action":"insert","lines":["="],"id":2132}],[{"start":{"row":465,"column":18},"end":{"row":465,"column":19},"action":"insert","lines":[" "],"id":2133}],[{"start":{"row":465,"column":19},"end":{"row":465,"column":20},"action":"insert","lines":["n"],"id":2134}],[{"start":{"row":465,"column":20},"end":{"row":465,"column":21},"action":"insert","lines":["u"],"id":2135}],[{"start":{"row":465,"column":21},"end":{"row":465,"column":22},"action":"insert","lines":["m"],"id":2136}],[{"start":{"row":465,"column":22},"end":{"row":465,"column":23},"action":"insert","lines":[";"],"id":2137}],[{"start":{"row":431,"column":6},"end":{"row":431,"column":55},"action":"remove","lines":["// TODO: get priority value and set to 'priority'"],"id":2138}],[{"start":{"row":431,"column":6},"end":{"row":432,"column":0},"action":"remove","lines":["",""],"id":2139}],[{"start":{"row":431,"column":6},"end":{"row":431,"column":8},"action":"remove","lines":["  "],"id":2140}],[{"start":{"row":431,"column":6},"end":{"row":431,"column":8},"action":"remove","lines":["  "],"id":2141}],[{"start":{"row":431,"column":6},"end":{"row":431,"column":8},"action":"remove","lines":["  "],"id":2142}]]},"ace":{"folds":[{"start":{"row":9,"column":8},"end":{"row":12,"column":0},"placeholder":"..."},{"start":{"row":25,"column":1},"end":{"row":27,"column":0},"placeholder":"..."},{"start":{"row":36,"column":1},"end":{"row":78,"column":0},"placeholder":"..."},{"start":{"row":84,"column":1},"end":{"row":116,"column":0},"placeholder":"..."},{"start":{"row":122,"column":1},"end":{"row":136,"column":0},"placeholder":"..."},{"start":{"row":143,"column":1},"end":{"row":182,"column":0},"placeholder":"..."},{"start":{"row":192,"column":1},"end":{"row":233,"column":0},"placeholder":"..."},{"start":{"row":239,"column":1},"end":{"row":282,"column":0},"placeholder":"..."},{"start":{"row":397,"column":59},"end":{"row":418,"column":4},"placeholder":"..."},{"start":{"row":457,"column":1},"end":{"row":467,"column":0},"placeholder":"..."},{"start":{"row":478,"column":1},"end":{"row":492,"column":0},"placeholder":"..."},{"start":{"row":497,"column":1},"end":{"row":502,"column":0},"placeholder":"..."},{"start":{"row":508,"column":1},"end":{"row":523,"column":0},"placeholder":"..."},{"start":{"row":529,"column":1},"end":{"row":560,"column":0},"placeholder":"..."},{"start":{"row":567,"column":1},"end":{"row":573,"column":0},"placeholder":"..."},{"start":{"row":578,"column":1},"end":{"row":582,"column":0},"placeholder":"..."},{"start":{"row":589,"column":1},"end":{"row":605,"column":0},"placeholder":"..."},{"start":{"row":613,"column":1},"end":{"row":642,"column":0},"placeholder":"..."},{"start":{"row":645,"column":13},"end":{"row":647,"column":0},"placeholder":"..."}],"scrolltop":1229.6667108535767,"scrollleft":0,"selection":{"start":{"row":320,"column":13},"end":{"row":320,"column":13},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":300,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1493593463206}